2월 7일 ESTSoft 오르미 백엔드 개발자 과정 부트캠프에서 자바 예외처리에 대해 학습하던 중 <b>트랜잭션</b>이라는 개념을 마주했다. <br>
'하나의 논리적인 작업 단위'로, 가령 송금 트랜잭션이 존재한다면 세부적인 작업 단위 중 어느 하나라도 실패해서는 안된다는 내용을 배웠고 그렇다면 왜 그 세부 단위들은 트랜잭션이 될 수 없는가..? 했을 때 세부 단위를 모은 하나의 과정을 트랜잭션으로 받아들였다. 그러나 여전히 애매하게 이해되는 부분들이 있었기에.. <br>

이것이 자바다 교재를 바탕으로 제작된 강의를 보고 트랜잭션에 대해 기록한다!
<br><br>
출처: https://www.youtube.com/watch?v=ecqxGfQMKXc
<br><br>

# 트랜잭션

- 기능 처리의 최소 단위를 의미한다. 하나의 기능은 여러 가지 소작업들로 구성되며, 최소 단위라는 것은 이 소작업들을 분리할 수 없고 전체를 하나로 본다는 개념이다.
- 트랜잭션은 소작업들이 모두 성공하거나 실패해야 한다.

<br>
(계좌 이체 예시)<br><br>

계좌 이체는 출금 작업가 입금 작업을 구성된 트랜잭션으로, 두 가지 작업이 모두 성공하거나 모두 실패해야 한다. → **All or Nothing** (출금은 성공했는데 입금은 실패한다, 또는 그 반대는 불가능하다)

<img src="https://github.com/biiit4894/oreumi-TIL/assets/82032418/22aebe93-595c-4950-bf6c-a22a4a6e137c">

계좌 이체는 db 입장에서는 두 개의 UPDATE문이 필요한 작업이다.

<img src="https://github.com/biiit4894/oreumi-TIL/assets/82032418/f9f009f6-1d3d-4da1-a26a-77e8ea1b2616">

<br>

## DB는 All or Nothing을 어떻게 구현할까?

DB는 트랜잭션을 처리하고 All or Nothing을 구현하기 위해 커밋과 롤백을 제공한다.

### 커밋

- 내부 작업을 모두 성공처리함

JDBC에서는 INSERT, UPDATE, DELETE문을 실행할 때마다 **자동 커밋**이 일어난다. (성공적으로 실행되면 자동으로 저장된다)

이 자동커밋에는 문제가 있으니.. 두 가지 UPDATE문을 실행한다면?!

출금 작업 또는 입금 작업 진행 도중에 예외가 발생한다면..? 이미 커밋된 것은 롤백시킬 수 없는데?!

따라서 JDBC에서는 트랜잭션을 코드로 제어하려면 자동 커밋 기능을 꺼야한다.

```java
conn.setAutoCommit(false); // setAutoCommit 메소드로 자동 커밋 기능 끄기

// 이후 롤백 제어
conn.commit(); // 커밋하기
conn.rollback(); // 롤백하기
```

### 롤백

- 작업 실행 전으로 돌아간다는 의미에서 **모두 실패 처리**함.

소작업 단계에서 예외 없이 정상적으로 처리된다면 commit이 될 것. 예외가 발생한다면 catch문에 진입되어 롤백이 된다. 이때 롤백은 성공한 작업도 실패 처리해버림.

연결을 끊기(conn.close) 전에는 꺼두었던 자동 커밋 기능을 다시 켜준다.

<img src="https://github.com/biiit4894/oreumi-TIL/assets/82032418/80ed021d-f20d-40dc-9b71-9e5ed665a127">

```java
Connection conn = null;

// 연결 후 ..
try {
	// 트랜잭션 시작
		conn.setAutoCommit(false); // 자동 커밋 기능 끄기
		// 소작업 처리 -> 출금
		// 소작업 처리 -> 입금
		conn.commit(); // 커밋 -> 모두 성공 처리
} catch(Exception e) {
		try {
			conn.rollback(); // 롤백 -> 모두 실패 처리
		} catch(SQLException e1) {}
} finally {
	if(conn != null) {
		try {
			conn.setAutoCommit(true); // 원래대로 자동 커밋 기능 켜기
			conn.close(); // 연결 끊기
		} catch(SQLException e) {}
	}
}
```

사실 이 단계에서는 자동 커밋 기능을 반드시 켜줄 필요는 없지만..

connection pool 개념을 고려했을 때, 자동 커밋을 처음에 꺼줬다면 원래대로 켜준 이후에 db와의 연결을 끊어주는 것이 맞다!

## connection pool

여러 개를 모아두고 관리하는 pool..

connection pool은 무엇일까?

⇒ DB 작업에서는 DB와의 연결 자체에 시간이 제법 오래 걸린다! 미리 연결하고 필요할 때 꺼내 쓰며 시간을 줄여 봐요~

다수의 클라이언트 요청을 처리하는 서버 프로그램은 대부분 커넥션 풀을 사용한다. 커넥션 풀은 일정량의 Connection을 미리 생성시켜놓고, 서버에서 클라이언트의 요청을 처리할 때 Connection을 제공해주고 다시 반환받는 역할을 수행한다. (DB와 연결되어있는 객체를 미리 만들어 놓고, 프로그램에서 연결이 필요하다 하면 요청 처리 단계에서 DB와 새롭게 연결하는 것이 아니라, 기존에 이미 연결되어있는 객체를 가져와 사용하고, 반환한다)

<img src="https://github.com/biiit4894/oreumi-TIL/assets/82032418/31dc4da1-de17-4a3a-90de-e7db37f4d186">

요청 처리 단계에서 바로 conn.close() 한다면? DB에서 직접 연결된 connection과 풀에 이미 존재하는 connection을 가져온 것 두가지는 close의 동작 방식이 다르다

1. 직접 연결 후 close : 말 그대로 DB 연결을 끊는 것
2. connection 기존 객체를 쓴 후 close : DB 연결을 끊는 것이 아니라, 4번 단계의 반납의 의미!

트랜잭션 작업을 위해 connection 객체를 하나 가져오고.. 요청 처리 단계에서 자동 커밋 기능을 꺼버리고.. 본격적으로 트랜잭션 작업을 처리한다고 가정해보자! 다 썼으니 connection을 이제 반환해야할텐데..

<u>자동 커밋 기능을 끈 상태에서 반납하면 트랜잭션 작업을 처리하지 않음에도 불구하고 커밋과 롤백을 수행해야 하기 때문에 다른 곳에서 지금 쓰는 connection 객체를 가져다 쓸 때 문제가 된다.</u> (?? 이 부분이 무슨 말인지 정확히 모르겠음) 반납할 때는 원래 상태로 돌려두고 반납해야 하기에 자동 커밋 기능을 켜야 하는 것!

커넥션 풀을 사용하면 생성된 Connection을 재사용할 수 있기 때문에 DB 연결 시간을 줄일 수 있고, 전체 Connection 수를 관리할 수도 있다. 따라서 불특정 다수의 클라이언트 요청을 처리하는 서버 프로그램에서는 필수 기능 중 하나이다.

<br>

---

<br>

부트캠프 교안에 왜 트랜잭션 처리가 적용된 코드가 수도 코드 정도로 추상적이었는지.. 설명이 추상적이었는지 의문이었는데, 아직 DB 처리를 배우지 않은 상태에서 DB와 연관된 트랜잭션을 배우는 상태였기 때문이 아니었을까 싶으면서 이제 조금은 그 이유가 이해가 된다.<br>
connection pool을 사용하는 이유에서 자동 커밋 기능을 꼭 다시 켜줘야한다는 부분은 아직 온전히 이해되지 않았고.. jdbc 이외의 환경에서도 동일한 쓰레드 개념이 적용될지는 아직 다 경험하지 못했지만, 향후 postgresql 실습 환경을 거치며 조금 더 고민해보자!
